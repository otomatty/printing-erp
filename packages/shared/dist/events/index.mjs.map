{"version":3,"sources":["../../src/events/index.tsx"],"names":[],"mappings":";;AA+DA,IAAM,gBAAmB,GAAA,aAAA;AAAA,EACvB;AACF,CAAA;AAEO,SAAS,iBAAA,CAGd,EAAE,QAAA,EAAqC,EAAA;AACvC,EAAA,MAAM,SAAY,GAAA,MAAA;AAAA,IAChB;AAAC,GACH;AAEA,EAAM,MAAA,IAAA,GAAO,WAAY,CAAA,CAAC,KAA0B,KAAA;AAClD,IAAA,MAAM,iBAAiB,SAAU,CAAA,OAAA,CAAQ,KAAM,CAAA,IAAI,KAAK,EAAC;AAEzD,IAAA,KAAA,MAAW,YAAY,cAAgB,EAAA;AACrC,MAAA,QAAA,CAAS,KAAK,CAAA;AAAA;AAChB,GACF,EAAG,EAAE,CAAA;AAEL,EAAA,MAAM,EAAK,GAAA,WAAA,CAAY,CAAC,SAAA,EAAc,QAAkC,KAAA;AACtE,IAAA,SAAA,CAAU,OAAU,GAAA;AAAA,MAClB,GAAG,SAAU,CAAA,OAAA;AAAA,MACb,CAAC,SAAS,GAAG,CAAC,GAAI,SAAU,CAAA,OAAA,CAAQ,SAAS,CAAA,IAAK,EAAC,EAAI,QAAQ;AAAA,KACjE;AAAA,GACF,EAAG,EAAE,CAAA;AAEL,EAAA,MAAM,GAAM,GAAA,WAAA,CAAY,CAAC,SAAA,EAAc,QAAkC,KAAA;AACvE,IAAA,SAAA,CAAU,OAAU,GAAA;AAAA,MAClB,GAAG,SAAU,CAAA,OAAA;AAAA,MACb,CAAC,SAAS,GAAI,CAAA,SAAA,CAAU,QAAQ,SAAS,CAAA,IAAK,EAAI,EAAA,MAAA;AAAA,QAChD,CAAC,OAAO,EAAO,KAAA;AAAA;AACjB,KACF;AAAA,GACF,EAAG,EAAE,CAAA;AAEL,EACE,uBAAA,KAAA,CAAA,aAAA,CAAC,gBAAiB,CAAA,QAAA,EAAjB,EAA0B,KAAA,EAAO,EAAE,IAAM,EAAA,EAAA,EAAI,GAAI,EAAA,EAAA,EAC/C,QACH,CAAA;AAEJ;AAEO,SAAS,YAEa,GAAA;AAC3B,EAAM,MAAA,OAAA,GAAU,WAAW,gBAAgB,CAAA;AAE3C,EAAA,IAAI,CAAC,OAAS,EAAA;AACZ,IAAM,MAAA,IAAI,MAAM,uDAAuD,CAAA;AAAA;AAGzE,EAAO,OAAA,OAAA;AACT","file":"index.mjs","sourcesContent":["'use client';\n\nimport { createContext, useCallback, useContext, useRef } from 'react';\n\ntype EmptyPayload = NonNullable<unknown>;\n\n// Base event types\nexport interface BaseAppEventTypes {\n  'user.signedIn': { userId: string };\n  'user.signedUp': { method: `magiclink` | `password` };\n  'user.updated': EmptyPayload;\n  'checkout.started': { planId: string; account?: string };\n\n  // Add more base event types here\n}\n\nexport type ConsumerProvidedEventTypes = EmptyPayload;\n\n// Helper type for extending event types\nexport type ExtendedAppEventTypes<\n  T extends ConsumerProvidedEventTypes = ConsumerProvidedEventTypes,\n> = BaseAppEventTypes & T;\n\n// Generic type for the entire module\nexport type AppEventType<T extends ConsumerProvidedEventTypes> =\n  keyof ExtendedAppEventTypes<T>;\n\nexport type AppEvent<\n  T extends ConsumerProvidedEventTypes = ConsumerProvidedEventTypes,\n  K extends AppEventType<T> = AppEventType<T>,\n> = {\n  type: K;\n  payload: ExtendedAppEventTypes<T>[K];\n};\n\nexport type EventCallback<\n  T extends ConsumerProvidedEventTypes,\n  K extends AppEventType<T> = AppEventType<T>,\n> = (event: AppEvent<T, K>) => void;\n\ninterface InternalAppEventsContextType<\n  T extends ConsumerProvidedEventTypes = ConsumerProvidedEventTypes,\n  K extends AppEventType<T> = AppEventType<T>,\n> {\n  emit: (event: AppEvent<never, never>) => void;\n  on: (eventType: K, callback: EventCallback<T, K>) => void;\n  off: (eventType: K, callback: EventCallback<T, K>) => void;\n}\n\ninterface AppEventsContextType<T extends ConsumerProvidedEventTypes> {\n  emit: <K extends AppEventType<T>>(event: AppEvent<T, K>) => void;\n\n  on: <K extends AppEventType<T>>(\n    eventType: K,\n    callback: EventCallback<T, K>\n  ) => void;\n\n  off: <K extends AppEventType<T>>(\n    eventType: K,\n    callback: EventCallback<T, K>\n  ) => void;\n}\n\nconst AppEventsContext = createContext<InternalAppEventsContextType | null>(\n  null\n);\n\nexport function AppEventsProvider<\n  T extends ConsumerProvidedEventTypes = ConsumerProvidedEventTypes,\n  K extends AppEventType<T> = AppEventType<T>,\n>({ children }: React.PropsWithChildren) {\n  const listeners = useRef<Record<K, EventCallback<T, K>[]>>(\n    {} as Record<K, EventCallback<T, K>[]>\n  );\n\n  const emit = useCallback((event: AppEvent<T, K>) => {\n    const eventListeners = listeners.current[event.type] ?? [];\n\n    for (const callback of eventListeners) {\n      callback(event);\n    }\n  }, []);\n\n  const on = useCallback((eventType: K, callback: EventCallback<T, K>) => {\n    listeners.current = {\n      ...listeners.current,\n      [eventType]: [...(listeners.current[eventType] ?? []), callback],\n    };\n  }, []) as AppEventsContextType<T>['on'];\n\n  const off = useCallback((eventType: K, callback: EventCallback<T, K>) => {\n    listeners.current = {\n      ...listeners.current,\n      [eventType]: (listeners.current[eventType] ?? []).filter(\n        (cb) => cb !== callback\n      ),\n    };\n  }, []) as AppEventsContextType<T>['off'];\n\n  return (\n    <AppEventsContext.Provider value={{ emit, on, off }}>\n      {children}\n    </AppEventsContext.Provider>\n  );\n}\n\nexport function useAppEvents<\n  T extends ConsumerProvidedEventTypes = ConsumerProvidedEventTypes,\n>(): AppEventsContextType<T> {\n  const context = useContext(AppEventsContext);\n\n  if (!context) {\n    throw new Error('useAppEvents must be used within an AppEventsProvider');\n  }\n\n  return context as AppEventsContextType<T>;\n}\n"]}