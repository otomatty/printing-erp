{"version":3,"sources":["../src/lib/utils/is-route-active.ts"],"names":["ROOT_PATH","isRouteActive","path","currentPath","end","checkIfRouteIsActive","targetLink","currentRoute","depth","currentRoutePath","isRoot","hasMatchingSegments","splitIntoSegments","href","segments","matchingSegments","numberOfMatchingSegments","count","segment"],"mappings":"AAAA,IAAMA,CAAY,CAAA,GAAA,CASX,SAASC,CAAAA,CACdC,CACAC,CAAAA,CAAAA,CACAC,CACA,CAAA,CAEA,OAAIF,CAAAA,GAASC,CACJ,CAAA,IAAA,CAIL,OAAOC,CAAQ,EAAA,UAAA,CACV,CAACA,CAAAA,CAAID,CAAW,CAAA,CAWlBE,CAAqBH,CAAAA,CAAAA,CAAMC,EAPfC,CAAO,EAAA,IAAA,CACL,CACG,CAAA,CAK4B,CACtD,CAUO,SAASC,CAAAA,CACdC,EACAC,CACAC,CAAAA,CAAAA,CAAQ,CACR,CAAA,CAEA,IAAMC,CAAAA,CAAmBF,CAAa,CAAA,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,EAAK,EAMvD,CAAA,OAJI,CAACG,CAAAA,CAAOD,CAAgB,CAAKC,EAAAA,CAAAA,CAAOJ,CAAU,CAAA,EAI9C,CAACG,CAAAA,CAAiB,QAASH,CAAAA,CAAU,EAChC,KAGWA,CAAAA,CAAAA,GAAeG,CAG1B,CAAA,IAAA,CAGFE,CAAoBL,CAAAA,CAAAA,CAAYG,CAAkBD,CAAAA,CAAK,CAChE,CAEA,SAASI,CAAkBC,CAAAA,CAAAA,CAAc,CACvC,OAAOA,CAAK,CAAA,KAAA,CAAM,GAAG,CAAA,CAAE,MAAO,CAAA,OAAO,CACvC,CAEA,SAASF,CAAAA,CACPL,EACAC,CACAC,CAAAA,CAAAA,CACA,CACA,IAAMM,CAAWF,CAAAA,CAAAA,CAAkBN,CAAU,CAAA,CACvCS,EAAmBC,CAAyBT,CAAAA,CAAAA,CAAcO,CAAQ,CAAA,CAExE,OAAIR,CAAAA,GAAeC,CACV,CAAA,IAAA,CAMFQ,EAAmBD,CAAS,CAAA,MAAA,EAAUN,CAAQ,CAAA,CAAA,CACvD,CAEA,SAASQ,CAAyBH,CAAAA,CAAAA,CAAcC,EAAoB,CAClE,IAAIG,CAAQ,CAAA,CAAA,CAEZ,IAAWC,IAAAA,CAAAA,IAAWN,CAAkBC,CAAAA,CAAI,EAE1C,GAAIC,CAAAA,CAAS,QAASI,CAAAA,CAAO,CAC3BD,CAAAA,CAAAA,EAAS,CAET,CAAA,KAAA,OAAOA,EAIX,OAAOA,CACT,CAEA,SAASP,CAAOR,CAAAA,CAAAA,CAAc,CAC5B,OAAOA,IAASF,CAClB","file":"chunk-PUBMDLHF.mjs","sourcesContent":["const ROOT_PATH = '/';\n\n/**\n * @name isRouteActive\n * @description A function to check if a route is active. This is used to\n * @param end\n * @param path\n * @param currentPath\n */\nexport function isRouteActive(\n  path: string,\n  currentPath: string,\n  end?: boolean | ((path: string) => boolean),\n) {\n  // if the path is the same as the current path, we return true\n  if (path === currentPath) {\n    return true;\n  }\n\n  // if the end prop is a function, we call it with the current path\n  if (typeof end === 'function') {\n    return !end(currentPath);\n  }\n\n  // otherwise - we use the evaluateIsRouteActive function\n  const defaultEnd = end ?? true;\n  const oneLevelDeep = 1;\n  const threeLevelsDeep = 3;\n\n  // how far down should segments be matched?\n  const depth = defaultEnd ? oneLevelDeep : threeLevelsDeep;\n\n  return checkIfRouteIsActive(path, currentPath, depth);\n}\n\n/**\n * @name checkIfRouteIsActive\n * @description A function to check if a route is active. This is used to\n * highlight the active link in the navigation.\n * @param targetLink - The link to check against\n * @param currentRoute - the current route\n * @param depth - how far down should segments be matched?\n */\nexport function checkIfRouteIsActive(\n  targetLink: string,\n  currentRoute: string,\n  depth = 1,\n) {\n  // we remove any eventual query param from the route's URL\n  const currentRoutePath = currentRoute.split('?')[0] ?? '';\n\n  if (!isRoot(currentRoutePath) && isRoot(targetLink)) {\n    return false;\n  }\n\n  if (!currentRoutePath.includes(targetLink)) {\n    return false;\n  }\n\n  const isSameRoute = targetLink === currentRoutePath;\n\n  if (isSameRoute) {\n    return true;\n  }\n\n  return hasMatchingSegments(targetLink, currentRoutePath, depth);\n}\n\nfunction splitIntoSegments(href: string) {\n  return href.split('/').filter(Boolean);\n}\n\nfunction hasMatchingSegments(\n  targetLink: string,\n  currentRoute: string,\n  depth: number,\n) {\n  const segments = splitIntoSegments(targetLink);\n  const matchingSegments = numberOfMatchingSegments(currentRoute, segments);\n\n  if (targetLink === currentRoute) {\n    return true;\n  }\n\n  // how far down should segments be matched?\n  // - if depth = 1 => only highlight the links of the immediate parent\n  // - if depth = 2 => for url = /account match /account/organization/members\n  return matchingSegments > segments.length - (depth - 1);\n}\n\nfunction numberOfMatchingSegments(href: string, segments: string[]) {\n  let count = 0;\n\n  for (const segment of splitIntoSegments(href)) {\n    // for as long as the segments match, keep counting + 1\n    if (segments.includes(segment)) {\n      count += 1;\n    } else {\n      return count;\n    }\n  }\n\n  return count;\n}\n\nfunction isRoot(path: string) {\n  return path === ROOT_PATH;\n}\n"]}