---
title: 概要
description: Mastraワークフローの概要と基本構造
order: 1
updated: 2025-04-10
---

# ワークフローによる複雑なLLM操作の処理

Mastraのワークフローは、分岐、並列実行、リソースの一時停止などの機能を備えた複雑な操作シーケンスをオーケストレーションするのに役立ちます。

## ワークフローを使用するタイミング

ほとんどのAIアプリケーションでは、言語モデルへの単一の呼び出し以上のものが必要です。複数のステップを実行したり、条件によって特定のパスをスキップしたり、ユーザー入力を受け取るまで実行を完全に一時停止したりすることが必要な場合があります。エージェントのツール呼び出しが十分に正確でない場合もあります。

Mastraのワークフローシステムは以下を提供します：

- ステップを定義し、それらを連携させる標準化された方法
- シンプル（線形）と高度（分岐、並列）の両方のパスのサポート
- 各ワークフロー実行を追跡するためのデバッグと可観測性機能

## 例

ワークフローを作成するには、1つまたは複数のステップを定義し、それらをリンクして、ワークフローをコミットしてから開始します。

## ワークフローの詳細

ワークフロー作成プロセスの各部分を詳しく見てみましょう：

### 1. ワークフローの作成

Mastraでワークフローを定義する方法は次のとおりです。nameフィールドはワークフローのAPIエンドポイント（/workflows/$NAME/）を決定し、triggerSchemaはワークフローのトリガーデータの構造を定義します：

```
src/mastra/workflow/index.ts
const myWorkflow = new Workflow({
  name: "my-workflow",
  triggerSchema: z.object({
    inputValue: z.number(),
  }),
});
```

### 2. ステップの定義

次に、ワークフローのステップを定義します。各ステップには独自の入力および出力スキーマを持たせることができます。ここでは、stepOneは入力値を2倍にし、stepTwoはstepOneが成功した場合にその結果をインクリメントします（簡単にするために、この例ではLLM呼び出しは行いません）：

```
src/mastra/workflow/index.ts
const stepOne = new Step({
  id: "stepOne",
  outputSchema: z.object({
    doubledValue: z.number(),
  }),
  execute: async ({ context }) => {
    const doubledValue = context.triggerData.inputValue * 2;
    return { doubledValue };
  },
});
 
const stepTwo = new Step({
  id: "stepTwo",
  execute: async ({ context }) => {
    const doubledValue = context.getStepResult(stepOne)?.doubledValue;
    if (!doubledValue) {
      return { incrementedValue: 0 };
    }
    return {
      incrementedValue: doubledValue + 1,
    };
  },
});
```

### 3. ステップのリンク

次に、制御フローを作成し、ワークフローを「コミット」（確定）します。この場合、stepOneが最初に実行され、その後にstepTwoが続きます。

```
src/mastra/workflow/index.ts
myWorkflow.step(stepOne).then(stepTwo).commit();
```

## ワークフローの登録

ロギングとテレメトリを有効にするために、ワークフローをMastraに登録します：

```
src/mastra/index.ts
import { Mastra } from "@mastra/core";
 
export const mastra = new Mastra({
  workflows: { myWorkflow },
});
```

動的なワークフローを作成する必要がある場合、ワークフローはコンテキストにmastraインスタンスを注入することもできます：

```
src/mastra/workflow/index.ts
import { Mastra } from "@mastra/core";
 
const mastra = new Mastra();
 
const myWorkflow = new Workflow({
  name: "my-workflow",
  mastra,
});
```

## ワークフローの実行

プログラムまたはAPI経由でワークフローを実行します：

```
src/mastra/run-workflow.ts

import { mastra } from "./index";
 
// ワークフローを取得
const myWorkflow = mastra.getWorkflow("myWorkflow");
const { runId, start } = myWorkflow.createRun();
 
// ワークフロー実行を開始
await start({ triggerData: { inputValue: 45 } });
```

または、API（mastra devの実行が必要）を使用します：

```
// ワークフローの実行を作成

curl --location 'http://localhost:4111/api/workflows/myWorkflow/start-async' \
     --header 'Content-Type: application/json' \
     --data '{
       "inputValue": 45
     }'
```

この例は基本を示しています：ワークフローを定義し、ステップを追加し、ワークフローをコミットしてから実行します。

## ステップの定義

ワークフローの基本的な構成要素は[ステップ](./steps.mdx)です。
ステップは入力と出力のスキーマを使用して定義され、以前のステップの結果を取得できます。

## 制御フロー

ワークフローでは、並列ステップ、分岐パスなどを含むステップを連鎖させる[制御フロー](./control-flow.mdx)を定義できます。

## ワークフロー変数

ステップ間でデータをマッピングしたり、動的なデータフローを作成したりする必要がある場合、[ワークフロー変数](./variables.mdx)は情報をあるステップから別のステップに渡し、ステップ出力内のネストされたプロパティにアクセスするための強力なメカニズムを提供します。

## 一時停止と再開

外部データ、ユーザー入力、または非同期イベントのために実行を一時停止する必要がある場合、[Mastraは任意のステップでの一時停止をサポート](./suspend-resume.mdx)し、ワークフローの状態を保持して後で再開できるようにします。

## 可観測性とデバッグ

Mastraワークフローは、[ワークフロー実行内の各ステップの入力と出力を自動的に記録](../observability/otel-config.mdx)し、このデータを好みのロギング、テレメトリ、または可観測性ツールに送信できるようにします。

次のことが可能です：

- 各ステップのステータス（成功、エラー、一時停止など）を追跡する
- 分析のためのラン固有のメタデータを保存する
- ログを転送することで、DatadogやNew Relicなどのサードパーティの可観測性プラットフォームと統合する

## 詳細なリソース

- Guidesセクションのワークフローガイドは、主要な概念をカバーするチュートリアルです。
- シーケンシャルステップのワークフロー例
- 並列ステップのワークフロー例
- 分岐パスのワークフロー例
- ワークフロー変数の例
- 循環依存関係のワークフロー例
- [一時停止と再開のワークフロー例](../../mastra-example/workflows/suspend-and-resume.mdx)
- メモリプロセッサ 