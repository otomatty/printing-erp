---
title: エラー処理
description: エラー処理の概要と使用方法
order: 7
updated: 2025-04-10
---

# ワークフローにおけるエラー処理

堅牢なエラー処理は本番環境のワークフローにとって不可欠です。
Mastraはエラーを適切に処理するための複数のメカニズムを提供し、ワークフローが障害から回復したり、必要に応じて適切に機能を縮退させたりすることを可能にします。

## 概要

Mastraワークフローにおけるエラー処理は以下の方法で実装できます：

- **ステップの再試行** - 失敗したステップを自動的に再試行
- **条件分岐** - ステップの成功または失敗に基づいて代替パスを作成
- **エラーモニタリング** - エラーをプログラムで監視して処理
- **結果ステータスチェック** - 後続のステップで前のステップのステータスを確認

## ステップの再試行

Mastraは、一時的なエラーにより失敗したステップのための組み込みの再試行メカニズムを提供します。
これは、一時的に利用できなくなる可能性のある外部サービスやリソースと対話するステップに特に役立ちます。

### 基本的な再試行設定

ワークフローレベルまたは個別のステップで再試行を設定できます：

```javascript
// ワークフローレベルの再試行設定
const workflow = new Workflow({
  name: 'my-workflow',
  retryConfig: {
    attempts: 3,    // 再試行回数
    delay: 1000,    // 再試行間の遅延（ミリ秒）
  },
});
 
// ステップレベルの再試行設定（ワークフローレベルの設定を上書き）
const apiStep = new Step({
  id: 'callApi',
  execute: async () => {
    // 失敗する可能性のあるAPI呼び出し
  },
  retryConfig: {
    attempts: 5,    // このステップは最大5回再試行されます
    delay: 2000,    // 再試行間は2秒の遅延があります
  },
});
```

ステップの再試行の詳細については、ステップ再試行リファレンスを参照してください。

## 条件分岐

条件ロジックを使用して、前のステップの成功または失敗に基づいて代替ワークフローパスを作成できます：

```javascript
// 条件分岐を持つワークフローを作成
const workflow = new Workflow({
  name: 'error-handling-workflow',
});
 
workflow
  .step(fetchDataStep)
  .then(processDataStep, {
    // fetchDataStepが成功した場合のみprocessDataStepを実行
    when: ({ context }) => {
      return context.steps.fetchDataStep?.status === 'success';
    },
  })
  .then(fallbackStep, {
    // fetchDataStepが失敗した場合にfallbackStepを実行
    when: ({ context }) => {
      return context.steps.fetchDataStep?.status === 'failed';
    },
  })
  .commit();
```

## エラーモニタリング

`watch`メソッドを使用してワークフローのエラーを監視できます：

```javascript
const { start, watch } = workflow.createRun();
 
watch(async ({ results }) => {
  // 失敗したステップを確認
  const failedSteps = Object.entries(results)
    .filter(([_, step]) => step.status === "failed")
    .map(([stepId]) => stepId);
 
  if (failedSteps.length > 0) {
    console.error(`Workflow has failed steps: ${failedSteps.join(', ')}`);
    // アラートやロギングなどの是正措置を取る
  }
});
 
await start();
```

## ステップ内でのエラー処理

ステップの実行関数内で、エラーをプログラムで処理できます：

```javascript
const robustStep = new Step({
  id: 'robustStep',
  execute: async ({ context }) => {
    try {
      // 主要な操作を試みる
      const result = await someRiskyOperation();
      return { success: true, data: result };
    } catch (error) {
      // エラーをログに記録
      console.error('Operation failed:', error);
 
      // 例外をスローする代わりに適切なフォールバック結果を返す
      return {
        success: false,
        error: error.message,
        fallbackData: 'Default value'
      };
    }
  },
});
```

## 前のステップの結果の確認

前のステップの結果に基づいて決定を下すことができます：

```javascript
const finalStep = new Step({
  id: 'finalStep',
  execute: async ({ context }) => {
    // 前のステップの結果を確認
    const step1Success = context.steps.step1?.status === 'success';
    const step2Success = context.steps.step2?.status === 'success';
 
    if (step1Success && step2Success) {
      // すべてのステップが成功
      return { status: 'complete', result: 'All operations succeeded' };
    } else if (step1Success) {
      // step1のみ成功
      return { status: 'partial', result: 'Partial completion' };
    } else {
      // 重大な失敗
      return { status: 'failed', result: 'Critical steps failed' };
    }
  },
});
```

## エラー処理のベストプラクティス

- **一時的な障害には再試行を使用する**: 一時的な問題が発生する可能性のあるステップに再試行ポリシーを設定します。

- **フォールバックパスを提供する**: 重要なステップが失敗した場合の代替パスでワークフローを設計します。

- **エラーシナリオを具体的にする**: 異なるタイプのエラーに対して異なる処理戦略を使用します。

- **エラーを包括的にログに記録する**: デバッグを支援するために、エラーをログに記録する際にコンテキスト情報を含めます。

- **失敗時に意味のあるデータを返す**: ステップが失敗した場合、下流のステップが決定を下すのに役立つ、失敗に関する構造化されたデータを返します。

- **べき等性を考慮する**: 重複した副作用を引き起こすことなく、ステップを安全に再試行できるようにします。

- **ワークフロー実行を監視する**: `watch`メソッドを使用してワークフロー実行を積極的に監視し、早期にエラーを検出します。

## 高度なエラー処理

より複雑なエラー処理シナリオには、以下を検討してください：

- **サーキットブレーカーの実装**: ステップが繰り返し失敗する場合は、再試行を停止しフォールバック戦略を使用します
- **タイムアウト処理の追加**: ワークフローが無期限にハングしないようにステップの時間制限を設定します
- **専用のエラー回復ワークフローの作成**: 重要なワークフローには、メインワークフローが失敗したときにトリガーできる別の回復ワークフローを作成します

## 関連項目

- ステップ再試行リファレンス
- Watchメソッドリファレンス
- ステップ条件
- 制御フロー
