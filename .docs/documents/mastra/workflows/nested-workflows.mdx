---
title: ネストされたワークフロー
description: ネストされたワークフローの概要と使用方法
order: 8
updated: 2025-04-10
---

# ネストされたワークフロー

Mastraでは、ワークフローを他のワークフロー内のステップとして使用することができ、モジュール化された再利用可能なワークフローコンポーネントを作成できます。この機能は、複雑なワークフローを小さく管理しやすい部分に整理し、コードの再利用を促進するのに役立ちます。

また、ネストされたワークフローを親ワークフロー内のステップとして見ることができるため、ワークフローの流れを視覚的に理解しやすくなります。

## 基本的な使用法

`step()`メソッドを使用して、ワークフローを別のワークフロー内のステップとして直接使用できます：

```javascript
// ネストされたワークフローを作成
const nestedWorkflow = new Workflow({ name: "nested-workflow" })
  .step(stepA)
  .then(stepB)
  .commit();
 
// ネストされたワークフローを親ワークフロー内で使用
const parentWorkflow = new Workflow({ name: "parent-workflow" })
  .step(nestedWorkflow, {
    variables: {
      city: {
        step: "trigger",
        path: "myTriggerInput",
      },
    },
  })
  .then(stepC)
  .commit();
```

ワークフローがステップとして使用される場合：

- ワークフローの名前をステップIDとして使用し、自動的にステップに変換されます
- ワークフローの結果は親ワークフローのコンテキストで利用できます
- ネストされたワークフローのステップは定義された順序で実行されます

## 結果へのアクセス

ネストされたワークフローからの結果は、ネストされたワークフローの名前の下で親ワークフローのコンテキストで利用できます。結果には、ネストされたワークフローのすべてのステップ出力が含まれます：

```javascript
const { results } = await parentWorkflow.start();
// ネストされたワークフローの結果にアクセス
const nestedWorkflowResult = results["nested-workflow"];
if (nestedWorkflowResult.status === "success") {
  const nestedResults = nestedWorkflowResult.output.results;
}
```

## ネストされたワークフローを使用した制御フロー

ネストされたワークフローは、通常のステップで利用可能なすべての制御フロー機能をサポートしています：

### 並列実行

複数のネストされたワークフローを並列に実行できます：

```javascript
parentWorkflow
  .step(nestedWorkflowA)
  .step(nestedWorkflowB)
  .after([nestedWorkflowA, nestedWorkflowB])
  .step(finalStep);
```

または、ワークフローの配列を使用して`step()`を使用する：

```javascript
parentWorkflow.step([nestedWorkflowA, nestedWorkflowB]).then(finalStep);
```

この場合、`then()`は最終ステップを実行する前に、すべてのワークフローが終了するのを暗黙的に待ちます。

### If-Else分岐

ネストされたワークフローは、両方の分岐を引数として受け入れる新しい構文を使用して、if-else分岐で使用できます：

```javascript
// 異なるパスのためのネストされたワークフローを作成
const workflowA = new Workflow({ name: "workflow-a" })
  .step(stepA1)
  .then(stepA2)
  .commit();
 
const workflowB = new Workflow({ name: "workflow-b" })
  .step(stepB1)
  .then(stepB2)
  .commit();
 
// ネストされたワークフローで新しいif-else構文を使用
parentWorkflow
  .step(initialStep)
  .if(
    async ({ context }) => {
      // ここに条件を記述
      return someCondition;
    },
    workflowA, // if分岐
    workflowB, // else分岐
  )
  .then(finalStep)
  .commit();
```

この新しい構文は、ネストされたワークフローを扱う際により簡潔で明確です。条件が：

- true: 最初のワークフロー（if分岐）が実行されます
- false: 2番目のワークフロー（else分岐）が実行されます

スキップされたワークフローは、結果で`skipped`というステータスになります：

if-elseブロックの後の`.then(finalStep)`呼び出しは、ifとelse分岐を単一の実行パスに戻します。

### ループ処理

ネストされたワークフローは、他のステップと同様に`.until()`と`.while()`ループを使用できます。興味深い新しいパターンの1つは、その結果について何かが真になるまでネストされたワークフローを実行し続けるために、ループバック引数としてワークフローを直接渡すことです：

```javascript
parentWorkflow
  .step(firstStep)
  .while(
    ({ context }) =>
      context.getStepResult("nested-workflow").output.results.someField ===
      "someValue",
    nestedWorkflow,
  )
  .step(finalStep)
  .commit();
```

## ネストされたワークフローの監視

親ワークフローの`watch`メソッドを使用して、ネストされたワークフローの状態変化を監視できます。これは、複雑なワークフローの進捗と状態遷移を監視するのに役立ちます：

```javascript
const parentWorkflow = new Workflow({ name: "parent-workflow" })
  .step([nestedWorkflowA, nestedWorkflowB])
  .then(finalStep)
  .commit();
 
const run = parentWorkflow.createRun();
const unwatch = parentWorkflow.watch((state) => {
  console.log("Current state:", state.value);
  // state.contextでネストされたワークフローの状態にアクセス
});
 
await run.start();
unwatch(); // 完了したら監視を停止
```

## 一時停止と再開

ネストされたワークフローは一時停止と再開をサポートし、特定のポイントでワークフロー実行を一時停止して続行することができます。ネストされたワークフロー全体または特定のステップを一時停止できます：

```javascript
// 一時停止が必要な場合があるステップを定義
const suspendableStep = new Step({
  id: "other",
  description: "Step that may need to suspend",
  execute: async ({ context, suspend }) => {
    if (!wasSuspended) {
      wasSuspended = true;
      await suspend();
    }
    return { other: 26 };
  },
});
 
// 一時停止可能なステップを持つネストされたワークフローを作成
const nestedWorkflow = new Workflow({ name: "nested-workflow-a" })
  .step(startStep)
  .then(suspendableStep)
  .then(finalStep)
  .commit();
 
// 親ワークフローで使用
const parentWorkflow = new Workflow({ name: "parent-workflow" })
  .step(beginStep)
  .then(nestedWorkflow)
  .then(lastStep)
  .commit();
 
// ワークフローを開始
const run = parentWorkflow.createRun();
const { runId, results } = await run.start({ triggerData: { startValue: 1 } });
 
// ネストされたワークフロー内の特定のステップが一時停止しているかチェック
if (results["nested-workflow-a"].output.results.other.status === "suspended") {
  // ドット記法を使用して特定の一時停止ステップを再開
  const resumedResults = await run.resume({
    stepId: "nested-workflow-a.other",
    context: { startValue: 1 },
  });
 
  // 再開された結果には、完了したネストされたワークフローが含まれます
  expect(resumedResults.results["nested-workflow-a"].output.results).toEqual({
    start: { output: { newValue: 1 }, status: "success" },
    other: { output: { other: 26 }, status: "success" },
    final: { output: { finalValue: 27 }, status: "success" },
  });
}
```

ネストされたワークフローを再開する場合：

- ワークフロー全体を再開するには、`resume()`を呼び出す際にネストされたワークフローの名前を`stepId`として使用します
- ネストされたワークフロー内の特定のステップを再開するには、ドット記法（nested-workflow.step-name）を使用します
- ネストされたワークフローは、提供されたコンテキストで一時停止されたステップから続行します
- ネストされたワークフローの結果内の特定のステップのステータスは、`results["nested-workflow"].output.results`を使用してチェックできます

## 結果スキーマとマッピング

ネストされたワークフローは、結果スキーマとマッピングを定義でき、型安全性とデータ変換に役立ちます。これは、ネストされたワークフローの出力が特定の構造と一致することを確認したい場合や、結果を親ワークフローで使用する前に変換する必要がある場合に特に便利です。

```javascript
// 結果スキーマとマッピングを持つネストされたワークフローを作成
const nestedWorkflow = new Workflow({
  name: "nested-workflow",
  result: {
    schema: z.object({
      total: z.number(),
      items: z.array(
        z.object({
          id: z.string(),
          value: z.number(),
        }),
      ),
    }),
    mapping: {
      // 変数構文を使用してステップ結果から値をマッピング
      total: { step: "step-a", path: "count" },
      items: { step: "step-b", path: "items" },
    },
  },
})
  .step(stepA)
  .then(stepB)
  .commit();
 
// 型安全な結果を持つ親ワークフローで使用
const parentWorkflow = new Workflow({ name: "parent-workflow" })
  .step(nestedWorkflow)
  .then(async ({ context }) => {
    const result = context.getStepResult("nested-workflow");
    // TypeScriptはresultの構造を知っています
    console.log(result.total); // number
    console.log(result.items); // Array<{ id: string, value: number }>
    return { success: true };
  })
  .commit();
```

## ベストプラクティス

- **モジュール性**: ネストされたワークフローを使用して関連するステップをカプセル化し、再利用可能なワークフローコンポーネントを作成します。
- **命名**: ネストされたワークフローには、親ワークフローでステップIDとして使用されるため、説明的な名前を付けます。
- **エラー処理**: ネストされたワークフローはエラーを親ワークフローに伝播するため、適切にエラーを処理します。
- **状態管理**: 各ネストされたワークフローは独自の状態を維持しますが、親ワークフローのコンテキストにアクセスできます。
- **一時停止**: ネストされたワークフローで一時停止を使用する場合は、ワークフロー全体の状態を考慮し、適切に再開を処理します。

## 例

ネストされたワークフローのさまざまな機能を示す完全な例を以下に示します：

```javascript
const workflowA = new Workflow({
  name: "workflow-a",
  result: {
    schema: z.object({
      activities: z.string(),
    }),
    mapping: {
      activities: {
        step: planActivities,
        path: "activities",
      },
    },
  },
})
  .step(fetchWeather)
  .then(planActivities)
  .commit();
 
const workflowB = new Workflow({
  name: "workflow-b",
  result: {
    schema: z.object({
      activities: z.string(),
    }),
    mapping: {
      activities: {
        step: planActivities,
        path: "activities",
      },
    },
  },
})
  .step(fetchWeather)
  .then(planActivities)
  .commit();
 
const weatherWorkflow = new Workflow({
  name: "weather-workflow",
  triggerSchema: z.object({
    cityA: z.string().describe("The city to get the weather for"),
    cityB: z.string().describe("The city to get the weather for"),
  }),
  result: {
    schema: z.object({
      activitiesA: z.string(),
      activitiesB: z.string(),
    }),
    mapping: {
      activitiesA: {
        step: workflowA,
        path: "result.activities",
      },
      activitiesB: {
        step: workflowB,
        path: "result.activities",
      },
    },
  },
})
  .step(workflowA, {
    variables: {
      city: {
        step: "trigger",
        path: "cityA",
      },
    },
  })
  .step(workflowB, {
    variables: {
      city: {
        step: "trigger",
        path: "cityB",
      },
    },
  });
 
weatherWorkflow.commit();
```

この例では：

- 型安全性のためにすべてのワークフローにスキーマを定義しています
- 各ステップには適切な入力と出力のスキーマがあります
- ネストされたワークフローには独自のトリガースキーマと結果マッピングがあります
- `.step()`呼び出しで変数構文を使用してデータが渡されます
- メインワークフローは両方のネストされたワークフローからのデータを組み合わせます

