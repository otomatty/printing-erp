---
title: 'コンシェルジュチャット機能におけるエラー原因特定と解決策'
description: ''
date: '2025-04-03'
author: 'Akimasa Sugai'
tags: ['コンシェルジュ', 'チャット', 'エラー', '原因特定', '解決策', 'トラブルシューティング']
---

# ギフトコンシェルジュ機能 デバッグ作業記録

## 1. はじめに

このドキュメントは、ギフトコンシェルジュ機能の開発において発生した一連の認証およびデータベース関連の問題と、その解決プロセスを記録するものです。同様の問題が発生した場合の参照、および将来的な開発における知見として活用することを目的とします。

## 2. 発生した主な問題と解決の概要

開発プロセスにおいて、主に以下の2つの大きな問題が発生しました。

1.  **クライアントサイドでの認証エラー (`AuthSessionMissingError`):**
    *   **問題:** チャットインターフェースの表示時やメッセージ送信時に、クライアントサイドで Supabase の認証セッションが見つからないエラーが頻発しました。
    *   **原因:** クライアントサイドコンポーネント (`ChatInterface.tsx`, `useChatRealtime.ts`) で、サーバーサイド/クライアントサイド共用の `@supabase/supabase-js` の `createClient` を使用していました。これはブラウザの Cookie の変更を自動で検知・反映できないため、ミドルウェアで更新されたセッション情報を認識できませんでした。
    *   **解決:** `@supabase/ssr` パッケージが提供するクライアントサイド専用の `createBrowserClient` を使用するように修正しました。これにより、ブラウザ環境でのセッション管理が正しく行われるようになりました。

2.  **メッセージ送信時の外部キー制約エラー:**
    *   **問題:** 認証エラー解決後、メッセージ送信時にデータベースの外部キー制約違反エラーが発生しました。エラーメッセージの内容が実際のスキーマと矛盾するなど、原因特定に時間を要しました。
    *   **原因:** 根本的な原因は、「コンシェルジュに相談する」ボタンを押した際に呼び出される `createConsultation` Server Action に、コンシェルジュの**プロファイルID** (`concierge_profiles.id`) ではなく、誤ってコンシェルジュの **Auth User ID** (`auth.users.id`) が渡されていたことでした。さらに、`consultations` テーブルの `concierge_id` カラムは Auth User ID を参照するように制約が設定されていたため、最終的に外部キー制約違反が発生していました。（途中で表示された不正確なエラーメッセージに混乱させられました。）
    *   **解決:**
        *   `createConsultation` アクションの呼び出し元 (`ConsultantList.tsx`) を修正し、正しいコンシェルジュの**プロファイルID**を渡すようにしました。
        *   `createConsultation` アクション内部を修正し、受け取ったプロファイルIDを使って `concierge_profiles` テーブルから対応する **Auth User ID** を検索し、その User ID を `consultations` テーブルの `concierge_id` に挿入するように変更しました。

## 3. 詳細な問題と解決プロセス (時系列)

### 3.1. クライアントサイドでの認証エラー (`AuthSessionMissingError`)

#### 発生状況

*   `createConsultation` Server Action が成功し、チャットページ (`/shop/gift-concierge/consultant/chat/[consultationId]`) にリダイレクトされた直後。
*   `ChatInterface.tsx` コンポーネントがマウントされ、`useEffect` 内で `supabase.auth.getUser()` を呼び出した際に、ブラウザコンソールに `AuthSessionMissingError: Auth session missing!` が表示される。
*   その後、メッセージを送信しようとすると、`useChatRealtime.ts` フック内の `sendMessage` 関数で `supabase.auth.getUser()` を呼び出した際にも同様のエラーが発生する。

#### 調査と試したこと

1.  **サーバーサイドログの確認:** ミドルウェア (`middleware.ts`, `lib/supabase/middleware.ts`) および `createConsultation` Server Action のログを確認。これらの箇所では `supabase.auth.getUser()` は成功しており、認証Cookieも正しく存在していた。
2.  **`@supabase/ssr` と Next.js 15 の互換性調査:** バージョン間の非互換性を疑い、GitHub Issuesなどを確認したが、直接的な原因とは断定できず。
3.  **クライアントコードの確認:** エラー発生箇所がクライアントサイドコンポーネント (`ChatInterface.tsx`, `useChatRealtime.ts`) であることを特定。これらのファイル内で Supabase クライアントの初期化方法を確認。

#### 原因特定

`ChatInterface.tsx` と `useChatRealtime.ts` の両方で、Supabase クライアントの初期化に `@supabase/supabase-js` の `createClient` が使用されていました。

```typescript
// 問題があったコード (例: ChatInterface.tsx)
import { createClient } from '@supabase/supabase-js';
// ...
const [supabase] = useState(() => createClient(...));
// ...
useEffect(() => {
  const fetchUser = async () => {
    await supabase.auth.getUser(); // ここで AuthSessionMissingError
  };
  fetchUser();
}, [supabase]);
```

`createClient` は、特に `@supabase/ssr` を使ってミドルウェアでセッション管理を行っている場合、クライアントサイドでの Cookie の変更（セッション更新）を自動的に反映しません。

#### 解決策

`@supabase/ssr` パッケージが提供する `createBrowserClient` を使用するように修正しました。これはブラウザ環境に特化しており、Cookie の変更を監視し、常に最新のセッション情報で動作します。

```typescript
// 修正後のコード (例: ChatInterface.tsx)
import { createBrowserClient } from '@supabase/ssr'; // ← 変更
// ...
// 環境変数チェックを追加
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
if (!supabaseUrl || !supabaseAnonKey) { throw new Error(...) }

const [supabase] = useState(() => createBrowserClient(supabaseUrl, supabaseAnonKey)); // ← 変更
// ...
useEffect(() => {
  const fetchUser = async () => {
    await supabase.auth.getUser(); // エラーが発生しなくなった
  };
  fetchUser();
}, [supabase]);
```

`useChatRealtime.ts` についても同様の修正を行いました。

### 3.2. メッセージ送信時の外部キー制約エラー

#### 発生状況 (段階的に変化)

1.  **初期エラー:** `createBrowserClient` への修正後、メッセージ送信時に以下のエラーが **ブラウザコンソール** に表示された。
    *   メッセージ: `insert or update on table "consultation_messages" violates foreign key constraint "consultation_messages_consultation_id_fkey"`
    *   詳細: `Key (consultation_id)=(...) is not present in table "concierge_consultations".`

2.  **中間エラー:** `ConsultantList.tsx` の修正後、「このコンシェルジュに相談する」ボタンクリック時に **サーバーログ** に以下のエラーが表示された。
    *   メッセージ: `insert or update on table "consultations" violates foreign key constraint "consultations_concierge_id_fkey"`
    *   詳細: `Key (concierge_id)=(...) is not present in table "users".`

#### 調査と試したこと

1.  **初期エラーの調査:**
    *   エラーメッセージにある外部キー制約 `consultation_messages_consultation_id_fkey` と参照先テーブル `concierge_consultations` が、実際のデータベーススキーマに存在するか確認。
        *   **結果:** 制約もテーブルも存在しなかった。エラーメッセージ自体が不正確である可能性が浮上。
    *   `consultation_messages` テーブルのトリガーとRLSポリシーを確認。
        *   **結果:** トリガーはなし。RLSポリシーは存在し、`consultations` テーブルを正しく参照していたが、INSERT時の `check_expression` が満たされていない可能性を疑った。
        *   `check_expression`: `((auth.role() = 'authenticated'::text) AND (sender_id = auth.uid()) AND (EXISTS ( SELECT 1 FROM consultations c WHERE ((c.id = consultation_messages.consultation_id) AND ((c.customer_id = auth.uid()) OR (c.concierge_id = auth.uid()))))))`
    *   RLSポリシーの条件を検証するため、`consultations` テーブルのデータを確認。
        *   **結果:** `id` がメッセージ送信時の `consultation_id` と一致するレコードは存在したが、そのレコードの `concierge_id` に、メッセージ送信者（顧客）の `user_id` が設定されていることが判明。これにより、RLSポリシーは満たされるはずなのにエラーが発生する矛盾が明確になった。

2.  **根本原因の特定:** `concierge_id` に顧客のIDが設定される原因を追跡。
    *   `createConsultation` Server Action (`lib/actions/consultantActions.ts`) のコードを確認。`concierge_id` には関数の引数 `conciergeId` を設定していた。
    *   `createConsultation` の呼び出し元である `ConsultantList.tsx` を確認。
        *   **結果:** 「このコンシェルジュに相談する」ボタンクリック時に、`createConsultation` へ渡す引数として、コンシェルジュのプロファイルID (`consultant.id`) ではなく、コンシェルジュの Auth User ID (`consultant.userId`) を渡していたことが判明。
    *   `ConsultantList.tsx` を修正し、正しいプロファイルID (`consultant.id`) を渡すように変更。

3.  **中間エラーの調査:**
    *   `ConsultantList.tsx` 修正後に発生したエラーメッセージを確認。今度は `consultations` テーブルの `concierge_id` カラムが `users` テーブルを参照する外部キー制約に違反していることが判明。
    *   `createConsultation` アクションはプロファイルIDを受け取るようになったが、それをそのまま `consultations.concierge_id` に挿入しようとしていたため、`users` テーブルに存在しないプロファイルIDが原因でエラーが発生していた。

#### 解決策

`createConsultation` Server Action (`lib/actions/consultantActions.ts`) を再度修正し、以下のロジックを追加しました。

1.  引数で受け取った `conciergeProfileId` を使用する。
2.  `concierge_profiles` テーブルを検索し、`conciergeProfileId` に一致するレコードの `user_id` (Auth User ID) を取得する。
3.  取得した `user_id` を `consultations` テーブルの `concierge_id` カラムに設定してレコードを挿入する。

```typescript
// 修正後の createConsultation 内の主要ロジック
// ... ユーザー認証 ...
const customerId = user.id;

// プロファイルIDからコンシェルジュのAuth User IDを取得
const { data: conciergeProfile, error: profileError } = await supabase
    .from('concierge_profiles')
    .select('user_id')
    .eq('id', conciergeProfileId)
    .single();
// ... profileError, conciergeProfile なしのハンドリング ...
const conciergeUserId = conciergeProfile.user_id;

// consultations テーブルに挿入 (concierge_id に conciergeUserId を使用)
const { data: newConsultation, error: insertError } = await supabase
  .from('consultations')
  .insert({
    customer_id: customerId,
    concierge_id: conciergeUserId, // ← 正しい User ID を設定
    status: 'pending',
  })
  .select('id')
  .single();
// ... insertError, newConsultation なしのハンドリング ...
```

この修正により、データベースの制約を満たす正しいデータが挿入されるようになり、メッセージ送信時のエラーは完全に解消されました。

## 4. まとめ

今回の一連のデバッグ作業から、以下の点が重要な知見として得られました。

*   **Supabase + Next.js (App Router) でのクライアント選択:** `@supabase/ssr` を使用する場合、クライアントサイドコンポーネントでは必ず `createBrowserClient` を使用する。`createClient` を使用すると予期せぬ認証エラーが発生する。
*   **エラーメッセージの検証:** データベースエラーなどのメッセージは重要な手がかりだが、必ずしも常に正確とは限らない。表示されたエラーメッセージと実際のスキーマやコードの動作に矛盾がないかを確認することが重要。
*   **IDの種類と役割の明確化:** `user_id (auth.users.id)`, `profile_id (e.g., concierge_profiles.id)` など、異なる種類のIDが混在する場合、それぞれの役割と、どのIDをどのカラムに格納・参照すべきかを正確に把握し、コードに反映する必要がある。テーブル設計や命名規則の段階で明確にしておくことが望ましい。
*   **Server Action の引数と呼び出し元の確認:** Server Action で問題が発生した場合、アクション内部だけでなく、それを呼び出すクライアント側のコード（特に渡している引数）も注意深く確認する必要がある。
